#include <stdio.h>
#include <stdlib.h>

#define MAXN 310  // limite do problema (n <= 300)

int parent[MAXN];
int size[MAXN];

// inicialização do DSU
void dsu_init(int n) {
    for (int i = 0; i < n; i++) {
        parent[i] = i;
        size[i] = 1;
    }
}

int find(int x) {
    if (parent[x] != x) parent[x] = find(parent[x]);
    return parent[x];
}

// Função de "union" com união por tamanho
void unite(int a, int b) {
    a = find(a);
    b = find(b);
    if (a == b) return;
    if (size[a] < size[b]) {
        parent[a] = b;
        size[b] += size[a];
    } else {
        parent[b] = a;
        size[a] += size[b];
    }
}

int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize) {
    int n = graphSize;
    dsu_init(n);

    // Construir componentes com Union-Find
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (graph[i][j]) {
                unite(i, j);
            }
        }
    }

    // contar tamanho das componentes
    int compSize[MAXN] = {0};
    for (int i = 0; i < n; i++) {
        compSize[find(i)]++;
    }

    // contar quantos infectados há em cada componente
    int compInfected[MAXN] = {0};
    for (int i = 0; i < initialSize; i++) {
        int root = find(initial[i]);
        compInfected[root]++;
    }

    // Escolher o nó para remover
    int ans = initial[0];
    int bestSaved = -1;

    for (int i = 0; i < initialSize; i++) {
        int node = initial[i];
        int root = find(node);

        int saved = 0;
        if (compInfected[root] == 1) {
            saved = compSize[root];
        }

        if (saved > bestSaved || (saved == bestSaved && node < ans)) {
            bestSaved = saved;
            ans = node;
        }
    }

    return ans;
}

